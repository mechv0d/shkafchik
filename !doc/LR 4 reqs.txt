Рефакторинг проекта: Применение современных архитектурных подходов
Цель:
Провести анализ архитектуры существующего проекта, выбрать оптимальный архитектурный подход (FSD, Clean Architecture, Layered), применить его на практике с правильными соглашениями об именовании и структурировании кода.
Чек-лист выполнения:
⚠️ ВАЖНОЕ ЗАМЕЧАНИЕ:
• Эта лабораторная работа выполняется на вашем СУЩЕСТВУЮЩЕМ React проекте!
• Цель - провести полный рефакторинг архитектуры вашего приложения
• Работа требует глубокого понимания лекционного материала по архитектуре
ЭТАП 1. Анализ текущего состояния проекта
1. Аудит существующей структуры:
• Задокументируйте текущую файловую структуру проекта
• Выявите проблемы: дублирование кода, тесная связанность, неправильный нейминг
• Определите компоненты, которые нарушают Single Responsibility Principle
• Найдите примеры смешивания ответственностей (UI логика + бизнес логика + API)
• Проанализируйте соглашения об именовании (консистентность camelCase, PascalCase)
2. Оценка технического долга:
• Составьте список проблемных мест в кодовой базе
• Оцените сложность поддержки текущего кода (по шкале 1-10)
• Определите, какие части кода сложнее всего тестировать
• Выявите циклические зависимости между модулями (если есть)
3. Определение требований:
• Опишите, какие критерии современного приложения не выполняются сейчас
• Определите приоритетные проблемы для решения
• Составьте список ожидаемых улучшений после рефакторинга
ЭТАП 2. Выбор и обоснование архитектурного подхода
4. Анализ архитектурных паттернов:
• Изучите 3 подхода из лекции: Layered Architecture, Feature-Sliced Design (FSD), Clean Architecture
• Для каждого подхода опишите преимущества и недостатки в контексте ВАШЕГО проекта
• Учитывайте: размер команды (1 человек), сложность проекта, планы на расширение
5. Выбор архитектуры:
• Выберите ОДИН архитектурный подход для вашего проекта
• Обоснуйте выбор письменно (минимум 200 слов):
- Почему именно этот подход подходит вашему проекту?
- Какие проблемы текущей архитектуры он решит?
- Какие риски и сложности могут возникнуть при переходе?
• Согласуйте выбор с преподавателем (если требуется)
6. Проектирование новой структуры:
• Нарисуйте схему новой файловой структуры проекта
• Определите слои/модули/фичи (в зависимости от выбранного подхода)
• Определите правила импортов между модулями
• Спроектируйте организацию shared/common компонентов
ЭТАП 3. Применение соглашений об именовании
7. Аудит текущего нейминга:
• Найдите все несоответствия naming conventions:
- Компоненты не в PascalCase
- Функции не в camelCase
- Константы не в SCREAMING_SNAKE_CASE
- Несогласованность в именах файлов (смешивание PascalCase и kebab-case)
8. Создание Naming Guidelines:
• Создайте документ NAMING_GUIDELINES.md с правилами для вашего проекта:
- Компоненты: PascalCase (UserProfile.tsx)
- Хуки: camelCase с префиксом 'use' (useAuth.ts)
- Утилиты: camelCase (formatDate.ts)
- Константы: SCREAMING_SNAKE_CASE (API_BASE_URL)
- Типы: PascalCase с суффиксом (UserData, UserProps)
- Файлы: выберите единый стиль и опишите его
9. Рефакторинг именования:
• Переименуйте ВСЕ файлы согласно вашим guidelines
• Переименуйте компоненты, функции, переменные
• Обновите все импорты (используйте функцию 'Rename Symbol' в IDE)
• Убедитесь, что проект собирается после переименования
ЭТАП 4. Реструктуризация проекта
10. Создание новой структуры папок:
• Создайте новую структуру согласно выбранной архитектуре
• Примеры структур:
Feature-Sliced Design:
src/
├── app/ # Инициализация (providers, router)
├── pages/ # Страницы
├── widgets/ # Крупные блоки (Header, Sidebar)
├── features/ # Бизнес-функции (LoginForm, AddToCart)
├── entities/ # Бизнес-сущности (User, Product)
└── shared/ # Переиспользуемый код (ui, api, utils)
Layered Architecture:
src/
├── presentation/ # UI компоненты и страницы
├── application/ # Бизнес-логика, хуки, services
├── domain/ # Модели, entities, валидация
└── infrastructure/ # API, storage, external services
11. Разделение ответственностей (Separation of Concerns):
• Создайте отдельную папку для API запросов (api/ или services/api/)
• Вынесите бизнес-логику из компонентов в кастомные хуки (hooks/)
• Создайте папку utils/ для чистых функций-утилит
• Создайте папку types/ или models/ для TypeScript типов
• Разделите компоненты на 'умные' (containers) и 'глупые' (presentational)
12. Миграция компонентов:
• Перенесите компоненты в новую структуру (по 2-3 компонента за раз)
• Для каждого компонента:
- Выделите API логику в отдельный модуль
- Извлеките бизнес-логику в кастомный хук
- Оставьте в компоненте только UI логику
• Обновляйте импорты постепенно
• Тестируйте функциональность после каждого шага
13. Реорганизация типов и интерфейсов:
• Соберите все TypeScript типы в одном месте (types/ или models/)
• Организуйте типы по доменам (user.types.ts, product.types.ts)
• Избегайте дублирования типов (используйте Partial, Pick, Omit)
• Создайте общие типы (common.types.ts или shared.types.ts)
ЭТАП 5. Применение принципов проектирования
14. DRY (Don't Repeat Yourself):
• Найдите дублирующийся код (минимум 3 примера)
• Вынесите повторяющуюся логику в переиспользуемые функции/хуки
• Создайте общие компоненты для повторяющихся UI паттернов
• Документируйте примеры применения DRY в отчете
15. KISS (Keep It Simple):
• Упростите сложные компоненты (разбейте на более мелкие)
• Рефакторите 'умный' код в более читаемый вариант
• Удалите неиспользуемый код (dead code)
• Примеры 'до' и 'после' включите в отчет
16. Single Responsibility Principle:
• Убедитесь, что каждый модуль имеет одну ответственность
• Разделите большие компоненты на более мелкие и специализированные
• Создайте отдельные хуки для разной логики (useAuth, useProducts, etc.)
ЭТАП 6. Оптимизация и проверка качества
17. Настройка ESLint и Prettier:
• Настройте или обновите конфигурацию ESLint
• Добавьте правила для naming conventions
• Настройте Prettier для единообразного форматирования
• Установите Husky + lint-staged для автопроверки перед коммитом
• Примените форматирование ко всему проекту
18. Code Review:
• Проверьте весь рефакторенный код:
- Нет ли циклических зависимостей?
- Соблюдаются ли правила импортов?
- Корректны ли все naming conventions?
- Разделены ли ответственности?
19. Проверка функциональности:
• Протестируйте ВСЕ функции приложения
• Убедитесь, что ничего не сломалось после рефакторинга
• Проверьте работу в разных браузерах
• Протестируйте edge cases
20. Анализ улучшений:
• Сравните структуру 'до' и 'после' (скриншоты файловой структуры)
• Оцените читаемость кода (по шкале 1-10 'до' и 'после')
• Проверьте bundle size (должен остаться примерно таким же или уменьшиться)
• Оцените время, необходимое для понимания кода новым разработчиком
ЭТАП 7. Документация и отчетность
21. Документация архитектуры:
• Создайте файл ARCHITECTURE.md с описанием:
- Выбранный архитектурный подход и его обоснование
- Структура проекта с описанием каждой папки
- Правила импортов и зависимостей между модулями
- Naming conventions проекта
- Примеры кода для каждого слоя/модуля
22. README обновление:
• Обновите README.md проекта:
- Добавьте раздел 'Архитектура проекта'
- Опишите структуру папок
- Добавьте ссылку на ARCHITECTURE.md
23. Git история:
• Создайте отдельную ветку: refactor/architecture-modernization
• Делайте осмысленные коммиты по этапам:
- refactor: add naming guidelines
- refactor: rename components to PascalCase
- refactor: create new folder structure
- refactor: separate API logic
- refactor: extract business logic to hooks
- refactor: apply DRY principle to components
- docs: add architecture documentation
24. Создание итогового отчета (PDF):
Структура отчета:
• Титульный лист
• Оглавление
• Введение (цели и задачи лабораторной работы)
• Раздел 1: Анализ текущего состояния
- Описание проекта
- Схема текущей структуры проекта
- Список выявленных проблем с примерами кода
- Оценка технического долга
• Раздел 2: Выбор архитектуры
- Сравнительная таблица рассмотренных подходов
- Обоснование выбора (минимум 200 слов)
- Схема новой архитектуры
- Правила организации кода
• Раздел 3: Применение naming conventions
- Документ NAMING_GUIDELINES.md
- Примеры переименования (минимум 5 примеров 'до' и 'после')
- Скриншоты изменений в IDE
• Раздел 4: Рефакторинг структуры
- Схема старой структуры (скриншот)
- Схема новой структуры (скриншот)
- Примеры применения Separation of Concerns (минимум 3 компонента)
- Код 'до' и 'после' для каждого примера
• Раздел 5: Применение принципов
- Примеры применения DRY (минимум 2 примера с кодом)
- Примеры применения KISS (минимум 2 примера с кодом)
- Примеры применения SRP (минимум 2 примера с кодом)
• Раздел 6: Результаты
- Сравнительная таблица 'до' и 'после':
* Количество файлов
* Глубина вложенности папок
* Средний размер компонента (строк кода)
* Оценка читаемости (1-10)
* Bundle size
- Скриншоты работающего приложения
- Скриншоты ESLint/Prettier конфигурации
• Раздел 7: Выводы
- Что удалось достичь
- Какие сложности возникли
- Что можно улучшить в будущем
- Личные выводы о важности архитектуры
• Приложения:
- Ссылка на GitHub репозиторий
- Полный текст ARCHITECTURE.md
- Полный текст NAMING_GUIDELINES.md